You are working inside ARC Intelligence Framework v2.0 (Express + TS + Postgres/Drizzle).

TASK:
Implement 3 MVPs in 60 minutes: (1) Causal Memory, (2) Agent Contracts enforcement, (3) Reflective Loop.
This is REAL implementation, not documentation.

CONSTRAINTS:
- Do NOT add new pages.
- Minimal code changes, production-safe.
- Primary DB is local Postgres via DATABASE_URL (Drizzle schema in shared/schema.ts).
- Every NEW endpoint MUST require header: X_ARC_SECRET == ARC_BACKEND_SECRET.
- For instrumentation/logging: ONLY log when header X_ARC_SECRET is present and valid.
- Keep naming consistent with existing codebase.
- Do not break existing endpoints.

HEADER STANDARDIZATION:
- Use ONLY: "X_ARC_SECRET" as the header name everywhere you add/modify auth.
- If legacy code uses "X-ARC-SECRET", support it temporarily by accepting BOTH, but prefer X_ARC_SECRET.
- ARC_BACKEND_SECRET is the expected secret value.

DELIVERABLES:

(1) CAUSAL MEMORY (DB + API)
Create 4 new tables in shared/schema.ts using Drizzle:

A) intent_log
- id (uuid, pk, default gen)
- created_at (timestamp, default now)
- actor_type enum: 'user'|'agent'|'system'|'external'
- actor_id (text)
- intent_type (text)
- intent_text (text)
- context (jsonb, nullable)

B) action_log
- id (uuid, pk)
- created_at (timestamp)
- intent_id (uuid FK -> intent_log.id, not null)
- action_type (text)
- action_target (text, nullable)
- request (jsonb, nullable)
- cost_usd (numeric, nullable)
- status enum: 'queued'|'running'|'success'|'failed'

C) result_log
- id (uuid, pk)
- created_at (timestamp)
- action_id (uuid FK -> action_log.id, not null)
- output (jsonb, nullable)
- error (text, nullable)
- latency_ms (int, nullable)

D) impact_log
- id (uuid, pk)
- created_at (timestamp)
- intent_id (uuid FK -> intent_log.id, not null)
- impact_type (text)
- impact_score (int, nullable)
- impact (jsonb, nullable)

INDEXES:
- intent_log(created_at), action_log(created_at), result_log(created_at), impact_log(created_at)
- action_log(intent_id), result_log(action_id), impact_log(intent_id)

STORAGE LAYER:
- Extend server/storage.ts IStorage with CRUD methods:
  createIntent, createAction, createResult, createImpact, getTimeline(limit)
- Implement in DatabaseStorage using Drizzle.

API ROUTES (in server/routes.ts or existing routing file):
All require auth via X_ARC_SECRET:
- POST /api/core/intent
  body: {actor_type, actor_id, intent_type, intent_text, context?}
  returns: {intent_id}
- POST /api/core/action
  body: {intent_id, action_type, action_target?, request?, cost_usd?, status?}
  returns: {action_id}
- POST /api/core/result
  body: {action_id, output?, error?, latency_ms?}
  returns: {result_id}
- POST /api/core/impact
  body: {intent_id, impact_type, impact_score?, impact?}
  returns: {impact_id}
- GET /api/core/timeline?limit=50
  returns last N intents joined with their actions/results/impacts in a structured JSON:
  [{ intent, actions:[{action, results:[...]}], impacts:[...] }]

INSTRUMENTATION (minimal, must not break things):
In the following flows, add optional logging:
- /api/chat
- /arc/execute
- /api/bio-sentinel/chat
- n8n inbound endpoints like /api/arc/receive or /api/arc/agent-events (if present)

Rules:
- Create intent_log when a request comes in (intent_type based on endpoint).
- Create action_log when you are about to call OpenAI or external HTTP, set status 'running'.
- On completion, update action status to success/failed (if you prefer, insert a new action row; but updating is better).
- Insert result_log with output or error and latency_ms.
IMPORTANT: only do this when X_ARC_SECRET is present and valid (to avoid logging public traffic).

(2) AGENT CONTRACTS (policy + enforcement)
Create file: arc_core/agent_contracts.json
Example structure:
{
  "default": {
    "allowed_actions": ["chat","tts","read_db"],
    "max_cost_usd_per_intent": 1.00,
    "risk_level": "low",
    "requires_confirmation": false
  },
  "mrf": {
    "allowed_actions": ["chat","tts","read_db","write_db","external_http","n8n_emit"],
    "max_cost_usd_per_intent": 25.00,
    "risk_level": "med",
    "requires_confirmation": false
  },
  "browser_automation": {
    "allowed_actions": ["external_http"],
    "max_cost_usd_per_intent": 10.00,
    "risk_level": "high",
    "requires_confirmation": true
  }
}

Implement contracts loader:
- module that reads arc_core/agent_contracts.json into memory
- supports reload without restart

Add endpoints (auth required with X_ARC_SECRET):
- GET /api/core/contracts  -> returns current contracts JSON
- POST /api/core/contracts/reload -> reload file and return {ok:true}

Enforcement middleware:
- Determine agent_id from:
  req.body.agent_id OR req.query.agent_id OR 'mrf' fallback.
- Determine action_type from:
  req.body.action_type OR infer from route (chat->'chat', tts->'tts', n8n emit->'n8n_emit', external http->'external_http', db writes->'write_db').
- Enforce:
  1) action_type must be in allowed_actions else 403.
  2) if requires_confirmation=true and req.body.confirmation_token missing -> 409 with JSON { required:"confirmation", agent_id, action_type }
  3) cost cap per intent:
     - if req.body.intent_id exists, sum action_log.cost_usd for that intent_id and block if exceed max_cost_usd_per_intent (403).
     - if no intent_id, do not block (MVP), but include warning in response header.

Apply middleware ONLY on endpoints that can cause side effects / cost:
- /api/chat
- /api/tts
- /arc/execute
- any external_http proxy endpoints (if exist)
- n8n outbound emitter (if exists)
Do not apply it on simple GET pages or public landing.

(3) REFLECTIVE LOOP (manual)
Create endpoint (auth required with X_ARC_SECRET):
- POST /api/core/reflect
  body: { window_minutes?: number } default 1440
It should:
- query causal tables for the window
- compute stats:
  total_intents
  total_actions
  success_actions
  failed_actions
  avg_latency_ms (from result_log)
  top_action_types (top 10)
  top_errors (top 10 by count from result_log.error)
- generate recommendations:
  If OPENAI_API_KEY exists, call OpenAI with a strict prompt to output JSON {recommendations:[...], risks:[...], next_actions:[...]}
  If not, produce rule-based recommendations (no AI call).
Store reflection output:
- If executive_summaries table exists in current schema and suitable, write there.
- Otherwise create new table reflections in shared/schema.ts:
  id uuid pk
  created_at timestamp
  window_minutes int
  stats jsonb
  top_errors jsonb
  recommendations jsonb

Return response: {ok:true, reflection_id, window_minutes, stats, top_errors, recommendations}

MIGRATIONS:
- Ensure schema changes are applied (drizzle push or migration).
- Fix any build/type errors.

OUTPUT REQUIREMENTS:
Return ONLY:
1) List of files changed/created
2) List of new endpoints
3) Exact curl commands to test:
   - create intent
   - create action
   - create result
   - get timeline
   - reflect
Include header usage using X_ARC_SECRET.

DO NOT include marketing text.
DO NOT propose future features beyond the requested MVPs.
